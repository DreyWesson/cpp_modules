#include "AMateria.hpp"

AMateria::AMateria() : _type("")
{
    // std::cout << "\033[2;37m""\033[3m" "AMATERIA constructor called\n" "\033[0m";
}

AMateria::~AMateria()
{
    // std::cout << "\033[2;37m""\033[3m" "AMATERIA destructor called\n" "\033[0m";
}

AMateria::AMateria(std::string const & type) : _type(type) {
    // std::cout << "\033[2;37m""\033[3m" "AMATERIA parameterized constructor called\n" "\033[0m";

}

AMateria::AMateria(AMateria const & cpy) {
    *this = cpy;
}

AMateria &AMateria::operator=(const AMateria &cpy) {
    if (this != &cpy)
       this-> _type = cpy._type;
    return (*this);
}

std::string const &AMateria::getType() const {
    return (this->_type);
}

// AMateria*   AMateria::clone() const; // do nothing - it's a pure virtual function

void AMateria::use(ICharacter& target) {
    std::cout << "AMateria used on " << target.getName() << " *";
}
#ifndef AMATERIA_H
#define AMATERIA_H

#include <iostream>
#include "ICharacter.hpp"

class ICharacter;

class AMateria
{
    protected:
    std::string _type;

    public:
    AMateria(void);
    AMateria(std::string const & type);
    AMateria(AMateria const & cpy);
    AMateria &operator=(const AMateria &cpy);
    virtual ~AMateria();

    std::string const & getType() const;
    virtual AMateria* clone() const = 0;
    virtual void use(ICharacter& target);
};

#endif

#include "Character.hpp"
#include "AMateria.hpp"

Character::Character() : _name("") {
    std::cout << "\033[2;37m""\033[3m" "CHARACTER constructor called\n" "\033[0m";
    for (int i = 0; i < 4; i++)
    {
        this->_inventory[i] = NULL;
        this->_leftOnFloor[i] = NULL;        
    }
}

Character::~Character() {
    for (int i = 0; i < 4; i++) {
        if (this->_inventory[i]) {
            delete this->_inventory[i];
            this->_inventory[i] = NULL;
        }
        if (this->_leftOnFloor[i]) {
            delete this->_leftOnFloor[i];
            this->_leftOnFloor[i] = NULL;
        }
    }
    std::cout << "\033[2;37m""\033[3m" "CHARACTER deconstructor called\n" "\033[0m";
}

Character::Character(std::string const &name) : _name(name) {
    std::cout << "\033[2;37m""\033[3m" "CHARACTER parameterized constructor called\n" "\033[0m";
    for (int i = 0; i < 4; i++)
    {
        this->_inventory[i] = NULL;
        this->_leftOnFloor[i] = NULL;        
    }
}

Character::Character(Character const &src) : _name(src._name) {
    for (int i = 0; i < 4; i++) {
        this->_inventory[i] = NULL;
        this->_inventory[i] = src._inventory[i];   
    }
    *this = src;
}

Character &Character::operator=(Character const &cpy) {
    /// @note BEFORE
    // if (this != &rhs)
    // {
    //     this->_name = rhs._name;
    //     for (int i = 0; i < 4; i++)
    //         this->_inventory[i] = rhs._inventory[i];
    // }
    // return *this;
    if (this != &cpy)
    {
        this->_name = cpy._name;
        for (int i = 0; i < 4; i++) {
            delete this->_inventory[i];
            if (cpy._inventory[i])
                this->_inventory[i] = cpy._inventory[i]->clone();
            else
                this->_inventory[i] = NULL;
            
        }
    }
    return (*this);
}

std::string const &Character::getName() const {
    return (this->_name);
}

void    Character::equip(AMateria* m) {
    for (int i = 0; i < 4; i++) {
        if (!this->_inventory[i]) {
            this->_inventory[i] = m->clone();
            std::cout << "Character " << this->_name << " equipped at index " << i << " with " << m->getType() << std::endl;
            break;
        }
    }
    std::cout << "DEBUG\n";
}

void Character::unequip(int idx) {
    /// @note 
    // if (idx >= 4 || !this->_inventory[idx])
    //     return ;
    // std::cout << "Character " << this->_name << " unequipped from index " << std::endl; 
    // delete this->_inventory[idx];
    // this->_inventory[idx] = NULL;

    if (idx >= 0 && idx < 4 && this->_inventory[idx]) {
            // Store the unequipped AMateria pointer for destruction
            this->_leftOnFloor[idx] = this->_inventory[idx];
            std::cout << "Character " << this->_name << " unequipped from index " << idx << std::endl;
            this->_inventory[idx] = NULL;
        } else {
            std::cout << "\033[31m""Invalid index or empty slot.""\033[0m" << std::endl;
        }
}

void    Character::use(int idx, ICharacter& target) {
    if (idx >= 0 && idx < 4 && this->_inventory[idx]) {
        std::cout << "Character " << this->_name << " uses " << this->_inventory[idx]->getType() << std::endl;
        this->_inventory[idx]->use(target);
    } else {
        std::cout << "\033[31m""Invalid index or empty slot.\n""\033[0m";
    }
}

#ifndef CHARACTER_H
#define CHARACTER_H

#include <iostream>
#include "ICharacter.hpp"
#include "AMateria.hpp"

class Character : public ICharacter
{
private:
    std::string _name;
    AMateria    *_inventory[4];
    AMateria* _leftOnFloor[4];

public:
    Character(void);
    Character(std::string const &name);
    Character(Character const &src);
    Character& operator=(Character const &rhs);
    ~Character();


    std::string const&  getName() const;
    void                equip(AMateria* m);
    void                unequip(int idx);
    void                use(int idx, ICharacter& target);
};

#endif

#include "AMateria.hpp"
#include "Cure.hpp"

Cure::Cure() : AMateria("cure")
{

    // std::cout << "\033[2;37m""\033[3m" "CURE constructor called\n" "\033[0m";

}

Cure::~Cure()
{
    // std::cout << "\033[2;37m""\033[3m" "CURE deconstructor called\n" "\033[0m";
}

Cure::Cure(const Cure &cpy) : AMateria("cure") {
    *this = cpy;
}

Cure &Cure::operator=(const Cure &cpy) {
    if (this != &cpy)
        this->_type = cpy._type;
    return (*this);
}

AMateria* Cure::clone() const {
    return (new Cure(*this));
}

void        Cure::use(ICharacter& target) {
    std::cout << "* heals " << target.getName() << "'s wounds *\n";
}

#ifndef CURE_H
#define CURE_H

#include <iostream>
#include "AMateria.hpp"

class Cure : public AMateria
{
public:
    Cure(void);
    Cure(const Cure &cpy);
    Cure &operator=(const Cure &cpy);
    ~Cure(void);

    virtual AMateria* clone() const;
    virtual void        use(ICharacter& target);
};

#endif

#include "AMateria.hpp"
#include "Ice.hpp"

Ice::Ice() : AMateria("ice")
{
    // std::cout << "\033[2;37m""\033[3m" "ICE constructor called\n" "\033[0m";

}

Ice::~Ice()
{
    // std::cout << "\033[2;37m""\033[3m" "ICE deconstructor called\n" "\033[0m";

}

Ice::Ice(const Ice &cpy) : AMateria("ice") {
    *this = cpy;
}

Ice &Ice::operator=(const Ice &cpy) {
    if (this != &cpy)
        AMateria::operator=(cpy);
    return (*this);
}

AMateria* Ice::clone() const {
    return (new Ice(*this));
}

void Ice::use(ICharacter& target) {
    std::cout << "* shoots an ice bolt at " << target.getName() << " *\n";
}

#ifndef ICE_H
#define ICE_H

#include <iostream>
#include "AMateria.hpp"

class Ice : public AMateria
{
private:

protected:
    
public:
    Ice(void);
    Ice(const Ice &cpy);
    Ice &operator=(const Ice &cpy);
    ~Ice(void);

    virtual AMateria* clone() const;
    virtual void        use(ICharacter& target);
};

#endif

#ifndef ICE_H
#define ICE_H

#include <iostream>
#include "AMateria.hpp"

class Ice : public AMateria
{
private:

protected:
    
public:
    Ice(void);
    Ice(const Ice &cpy);
    Ice &operator=(const Ice &cpy);
    ~Ice(void);

    virtual AMateria* clone() const;
    virtual void        use(ICharacter& target);
};

#endif

#ifndef IMATERIASOURCE_H
#define IMATERIASOURCE_H

#include "AMateria.hpp"

class AMateria;
class IMateriaSource
{
public:
    virtual ~IMateriaSource() {}
    virtual void learnMateria(AMateria*) = 0;
    virtual AMateria* createMateria(std::string const & type) = 0;
};

#endif

#include "AMateria.hpp"
#include "MateriaSource.hpp"


MateriaSource::MateriaSource()
{
    std::cout << "\033[2;37m""\033[3m" "MATERIASOURCE constructor called\n" "\033[0m";
        for (int i = 0; i < 4; i++)
            _store[i] = NULL;
}

MateriaSource::~MateriaSource()
{
    std::cout << "\033[2;37m""\033[3m" "MATERIASOURCE destructor called\n" "\033[0m";
    for (int i = 0; i < 4; i++) {
        delete _store[i];
        _store[i] = NULL;
    }
}

MateriaSource::MateriaSource(MateriaSource const & cpy) {
    for (int i = 0; i < 4; i++)
    {
        this->_store[i] = NULL;
        this->_store[i] = cpy._store[i];
    }
    *this = cpy;
}

MateriaSource &MateriaSource::operator=(const MateriaSource &cpy) {
    if (this != &cpy) {
        for (int i = 0; i < 4; i++)
        {
            delete this->_store[i];
            if (cpy._store[i])
                this->_store[i] = cpy._store[i]->clone();
            else
                this->_store[i] = NULL;
        }
    }
    return (*this);
}
void MateriaSource::learnMateria(AMateria* cpy) {
    for (int i = 0; i < 4; i++) {
        if (!_store[i]) {
            _store[i] = cpy->clone();
            break;
        }
    }
}


AMateria* MateriaSource::createMateria(std::string const & type) {
    for (int i = 0; i < 4; i++) {
        if (_store[i] && _store[i]->getType() == type)
            return (_store[i]->clone());
    }
    return (0);
}

AMateria* MateriaSource::getMateria( std::string const & type )
{
    for (int i = 0; i < 4; i++)
        if (_store[i] && _store[i]->getType() == type)
            return _store[i];
    return NULL;
}

#ifndef MATERIASOURCE_H
#define MATERIASOURCE_H

#include "IMateriaSource.hpp"

class MateriaSource : public IMateriaSource {
private:
    AMateria* _store[4];

public:
    MateriaSource(void);
    MateriaSource(const MateriaSource &src);
    MateriaSource& operator=(const MateriaSource &src);
    ~MateriaSource(void);

    virtual void learnMateria(AMateria*);
    virtual AMateria* createMateria(std::string const & type);
    AMateria* getMateria( std::string const & type);
};

#endif
#include "AMateria.hpp"
#include "Character.hpp"
#include "Ice.hpp"
#include "Cure.hpp"
#include "MateriaSource.hpp"
int main()
{
    IMateriaSource* src = new MateriaSource();
    src->learnMateria(new Ice());
    src->learnMateria(new Cure());
    ICharacter* me = new Character("me");
    AMateria* tmp;
    tmp = src->createMateria("ice");
    me->equip(tmp);
    // std::cout << "DEBUG\n";
    tmp = src->createMateria("cure");
    me->equip(tmp);
    ICharacter* bob = new Character("bob");
    me->use(0, *bob);
    me->use(1, *bob);
    delete bob;
    delete me;
    delete src;
    // debug_logic();
    return 0;
}